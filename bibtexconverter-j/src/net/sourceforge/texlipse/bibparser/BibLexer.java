/*
 * $Id$
 *
 * Copyright (c) 2004-2005 Oskar Ojala
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package net.sourceforge.texlipse.bibparser;

import net.sourceforge.texlipse.bibparser.lexer.Lexer;
import net.sourceforge.texlipse.bibparser.lexer.LexerException;
import net.sourceforge.texlipse.bibparser.node.EOF;
import net.sourceforge.texlipse.bibparser.node.TLBrace;
import net.sourceforge.texlipse.bibparser.node.TRBrace;
import net.sourceforge.texlipse.bibparser.node.TStringLiteral;
import net.sourceforge.texlipse.bibparser.node.TWhitespace;
import net.sourceforge.texlipse.bibparser.node.Token;

/**
 * BibTeX lexer. Extends the lexer generated by SableCC from the
 * generation file. Implements handling strings with matched braces.
 *
 * @author Oskar Ojala
 */
public class BibLexer extends Lexer {

    private int count;

    private Token stringStart;
    private StringBuffer text;

    /**
     * Constructs a new lexer.
     *
     * @param in The reader to read the characters from
     */
    public BibLexer(java.io.PushbackReader in) {
        super(in);
    }

    /**
     * We define a filter that recognizes braced strings and removes
     * the scribe-comments
     */
    protected void filter() throws LexerException {

        if (state.equals(State.BRACESTRING)) {

            // if we are just entering this state, first token is '{'
            if (stringStart == null) {

                stringStart = token;
                text = new StringBuffer("");
                count = 1;
                token = null; // continue to scan the input.

            } else {
                if (token instanceof TLBrace)
                    count++;
                else if (token instanceof TRBrace)
                    count--;
                else if (token instanceof EOF) {
                    throw new LexerException("[" + stringStart.getLine() +
                            "," + stringStart.getPos() + "] Unexpected end of file");
                }
                if (count != 0) {
                    // accumulate the string and continue to scan the input.
                    if (token instanceof TWhitespace)
                        text.append(" ");
                    else
                        text.append(token.getText());
                    token = null;
                } else {
                    TStringLiteral tsl = new TStringLiteral(text.toString(),
                            stringStart.getLine(),
                            stringStart.getPos());
                    // emit the string
                    token = tsl;
                    state = State.ASSIGN; //go back to assign mode
                    stringStart = null;
                }
            }
        } else if (state.equals(State.REMOVE)) {
            if (token instanceof TLBrace) {
                count++;
                if (stringStart == null)
                    stringStart = token;
            } else if (token instanceof TRBrace) {
                count--;
            } else if (token instanceof EOF) {
                throw new LexerException("[" + stringStart.getLine() +
                        "," + stringStart.getPos() + "] Unexpected end of file");
            }
            token = null;
            if (count == 0 && stringStart != null) {
                state = State.NORMAL;
                stringStart = null;
            }
        }
    }
}
